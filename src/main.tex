\documentclass[runningheads]{llncs}


\usepackage[utf8]{inputenc}
\usepackage{graphicx}
\usepackage{minted}
\usepackage{hyperref}
\hypersetup{
    colorlinks=true,
    linkcolor=blue,
    filecolor=magenta,      
    urlcolor=cyan,
    pdftitle={Overleaf Example},
    pdfpagemode=FullScreen,
    }
\urlstyle{same}
\usepackage{booktabs}       % professional-quality tables
\usepackage{amsfonts}       % blackboard math symbols
\usepackage{nicefrac}       % compact symbols for 1/2, etc.
\usepackage{microtype}      % microtypography

\usepackage{listings}
\usepackage{amsmath}
\usepackage{cleveref}       % smart cross-referencing, load after amsmath

% This LaTeX Document is intended to be used on Overleaf 

\usemintedstyle{vs}
\usepackage[dvipsnames]{xcolor}
%
% If you use the hyperref package, please uncomment the following line
% to display URLs in blue roman font according to Springer's eBook style:


\begin{document}


%
\title{Procedural approaches towards Maximal Extracted Value}
%
\author{Alexander Sandy Bradley\inst{1,2} \and
Sam Bacha\inst{1,2} \and
et al\inst{1}}
%
%\authorrunning{F. Author et al.}
% First names are abbreviated in the running head.
% If there are more than two authors, 'et al.' is used.
%
\institute{Manifold Finance, Inc\and CommodityStream, Ltd.\\
\email{\{sandy,sam\}@manifoldfinance.com}\\
\email{janitor@manifoldfinance.com}}


%
\maketitle              % typeset the header of the contribution

\keywords{MEV, \and Miner Extractable Value \and trade optimization, \and EVM \and uniswap \and sushiswap \and ethereum \and formal verification}

\tableofcontents

\newpage 
%--------------------------------------------------------------------------------------------------------------------------------------
\chapter{Protocol Specificcation}
\begin{abstract}
    MEV is sucks. \newline
MEV suck, Sandwiches sucks, use OpenMEVs.~\cite{openmev}.
\end{abstract}

\subsection{Design}
The Original design for the router was to use flashloans only to arbitrage then immediately distribute profits to hard coded addresses. Apart from the issue of hard coded addresses, this setup was inefficient because of small amounts frequently being split and transferring to multiple addresses being expensive. This opened the possibility of leaving profits to accumulate on the router. Furthermore it provides a way to arbitrage without a flashloan, saving gas and the loan fee (i.e. more profit, less gas). Additionally, the harvesting profits means ownership control of the router. A more robust 2 step process was chosen to control and transfer router ownership and harvest control. Ideal setup would be multisig consensus ownership.

\footnote{Ownership control of the router is not an issue, as a new router can be used or fallback to the legacy router contract.}


\newpage
\section{Motivation and Requirements}

%---------------------------------------------------------------------------------------------------------------------------
\subsection{Security properties}

In following the standards set forth by the UniswapV02/SushiswapV01 router contracts, the SushiswapV02 router contracts are intended to be safe to use with:

Potentially re-entrant tokens
Tokens that do not return from transfer
Pathological Tokens The SushiswapV02 router contracts are not intended to be used tokens that exhibit the following behavior
Tokens that exhibit a discretizing inflation curve
Tokens that exhibit an 'unowned' supply
Tokens that implement user defined types for standard mathematical operations
Numerical error analysis The engineering team would like to request a review of the numerical error incurred during contract execution, with a focus on the desirable invariant proposed by both the development team and auditors. Examples include any significant rounding error, if any, in a swap, favors the pool. etc.

%----------------------------------------------------------------------------------------------------------------------------------------

\subsection{Conformant Algorithms}	

Conformant Algorithms
Our requirements are phrased in the imperative, as such, part of algorithms (such as "strip any leading space characters" or "return false and abort these steps") are to be interpreted with the meaning of the RFC/EIP defined key words ("must", "should", "may", etc) used in introducing algorithms

\hfill \break

Conformance requirements phrased as algorithms or specific steps that can be implemented in any manner, so long as the end result are equivalent. In particular, the algorithms defined in this specification are intended to be easy to understand and are not necessarily intended to be performant. Implementers are encouraged to either: switch to an L2, optimize, or use Vyper\footnote{Vyperlang: https://vyper.readthedocs.io/en/stable/}.


%------------------------------------------------------------------------------------------------------------------------------------------------
\section{Swap Execution}
	

Presented herein, a derivation of optimal arbitrage between 2 Constant Product Automated Market Maker (CPAAM), Decentralised Exchanges (DEXs) for usage in procedural processes that enable value extraction (i.e. MEV).
This math is applied in the new Sushiswap router for at the source of  Miner Extractable Value (MEV). These trades post user swaps atomically. 
Profits are distributed to liquidity providers, in turn giving users better rates. Extracting MEV at source protects user trades from front-run attacks inherently and helps prevent fee spikes from attackers.


Slippage: The amount of price impact that a liquidator engenders when trying to sell collateral.
Slippage is denoted \text{$\Delta p(q)$} and is formally defined as the difference between the midpoint price at time $t, p_{\text {mid }}(t)$ and the execution price,  \text{$p_{\text {exec }}(q, t)$} for a traded quantity $q$ at time $$t, \Delta p(q, t)=p_{\text {mid }}(t)-p_{\text {exec }}(q, t)$$. This quantity is usually a function of other variables, such as implied and realized volatility. 
\footnote{Slippage is also known as market impact within academic literature.}


\subsection{Router Implementation}
As a general approach to security, deviation from current UniswapV2Router was kept to a minimum. Pair contract calls should be consistent with the existing router. Reliance on the new router storing and transferring tokens brings in a new attack vector. A robust Ownership setup, as above, was chosen to mitigate this threat along with reduction of functions accessing the funds. 2 helper libraries were also chosen from \text{solmate} to supersede \text{UniswapV2Helper} libraries for security.

safeTransferLib
ERC20
Since UniswapV2Router was not designed to store tokens, some functions are not compatible and had to be changed. E.g.

\begin{minted}{lexer.py:SolidityLexer -x}

removeLiquidityETHSupportingFeeOnTransferTokens

(, amountETH) = removeLiquidity(
    token,
    WETH,
    liquidity,
    amountTokenMin,
    amountETHMin,
    address(this),
    deadline
);
TransferHelper.safeTransfer(token, to, IERC20(token).balanceOf(address(this)));
\end{minted}
Changes to

\begin{minted}{lexer.py:SolidityLexer -x}
uint256 balanceBefore = ERC20(token).balanceOf(address(this));
(, amountETH) = removeLiquidity(token, weth, liquidity, amountTokenMin, amountETHMin, 
address(this), 
deadline);
ERC20(token).safeTransfer(to, ERC20(token).balanceOf(address(this)) - balanceBefore);
\end{minted}

\newpage
	
\chapter{Mathematical Model}


    
	
	The following sections describe the derivation of the optimal sizes for post user swap arbitrage between UniswapV2 style exchanges.
	
	\footnote{Benchmarking contracts for establishing a baseline can be found here: https://github.com/manifoldfinance/v2-periphery/tree/master/contracts }
	
	

	%------------------------------------------------
	
	\section{Constant Product Automated Market Maker}
	Constant Product Automated Market Makers (CPAMMs) are smart contracts for token liquidity pairs. UniswapV2 and SushiswapV1 are all governed by the constant product formula given in equation \ref{eqn:constProduct}. 
	
	\begin{eqnarray}
		k  &=& R_{\alpha}  R_{\beta}  \label{eqn:constProduct}
	\end{eqnarray}
	
	Where \(R_{\alpha}\) corresponds to the Reserves of token \(\alpha\), \(R_{\beta}\) to the Reserves of token \(\beta\) within the pair contract and \( k \) the constant invariant. 
	
	A swap trading \( \Delta\beta\) tokens for \( \Delta\alpha \) must satisfy equation \ref{eqn:swap}.
	
	\begin{eqnarray}
		k  &=& (R_{\alpha} - \Delta\alpha)  (R_{\beta} + \gamma\Delta\beta ) \label{eqn:swap}\\
		\gamma  &=& 1 - fee \label{eqn:gamma}
	\end{eqnarray}
	
	Where the fee on UniswapV02 and SushiswapV01 is 0.3\% and 0.25\% respectively. For big integer math, equation \ref{eqn:gamma} can be written in the form of equation \ref{eqn:gammaBig}.
	
	\begin{eqnarray}
		\gamma  &=& \frac{997}{1000} \label{eqn:gammaBig}
	\end{eqnarray}
	
	From equations \ref{eqn:constProduct} and \ref{eqn:swap} we can derive an equations for the expected amounts out and in, given in equations \ref{eqn:amountOut} and \ref{eqn:amountIn}. 
	
	\begin{eqnarray}
		amountOut: \Delta\alpha  &=& \frac{997 R_{\alpha} \Delta\beta }{1000 R_{\beta} + 997 \Delta\beta} \label{eqn:amountOut}\\
		amountIn: \Delta\beta  &=& \frac{1000 R_{\beta} \Delta\alpha }{997 (R_{\alpha} - \Delta\alpha)} \label{eqn:amountIn}
	\end{eqnarray}
	
	Post swap, the new liquidity reserves are modified as shown in equations \ref{eqn:reserveA} and \ref{eqn:reserveB}.
	
	\begin{eqnarray}
		R_{\alpha}{new}  &=& R_{\alpha}{old} - \Delta\alpha  \label{eqn:reserveA}\\
		R_{\beta}{new}  &=& R_{\beta}{old} + \Delta\beta  \label{eqn:reserveB}
	\end{eqnarray}
	
	Therefore sequential swaps can be simulated off-chain in a deterministic way, given the current liquidity state.
	
	\section{Minimal Procedural DEX Arbitrage}
	Establishing a minimal swap for DEX arbitrage consists of a single swap on one DEX followed by the reverse swap on another.
	
	Token amount swap path:
	\begin{eqnarray}
		DEX0: \: \: \Delta\beta_{0} \Rightarrow \Delta\alpha_{0}\\
		DEX1: \: \: \Delta\alpha_{0} \Rightarrow \Delta\beta_{1}
	\end{eqnarray}
	
	\section{Optimal simple DEX arbitrage size}
	From equation \ref{eqn:amountOut}, the definition of a simple DEX arbitrage for CPAMMs can be written in the form of equations \ref{eqn:dex1} and \ref{eqn:dex2}.
	
	\begin{eqnarray}
		 \Delta\alpha_{0}  &=& \frac{997 R_{\alpha 0} \Delta\beta_{0} }{1000 R_{\beta 0} + 997 \Delta\beta_{0}} \label{eqn:dex1}\\
		 \Delta\beta_{1}  &=& \frac{997 R_{\beta 1} \Delta\alpha_{0} }{1000 R_{\alpha 1} + 997 \Delta\alpha_{0}} \label{eqn:dex2}
	\end{eqnarray}
	
	Profit of the arbitrage is simply the amount out of the second trade minus the amount in of the first, shown by equation \ref{eqn:profit}.
	
	\begin{eqnarray}
		profit: y  &=& \Delta\beta_{1} - \Delta\beta_{0} \label{eqn:profit}
	\end{eqnarray}
	
	
	Substituting equation \ref{eqn:dex1} into equation \ref{eqn:dex2}, we get equation \ref{eqn:suby}.
	
	\begin{eqnarray}
		\Delta\beta_{1}  &=& \frac{997 R_{\beta 1} \frac{997 R_{\alpha 0} \Delta\beta_{0} }{1000 R_{\beta 0} + 997 \Delta\beta_{0}} }{1000 R_{\alpha 1} + 997 \frac{997 R_{\alpha 0} \Delta\beta_{0} }{1000 R_{\beta 0} + 997 \Delta\beta_{0}}} \label{eqn:suby}\\
		&=& \frac{997^2 R_{\beta 1}  R_{\alpha 0} \Delta\beta_{0} }{(1000 R_{\beta 0} + 997 \Delta\beta_{0}) 1000 R_{\alpha 1} + 997^2 R_{\alpha 0} \Delta\beta_{0} } \label{eqn:subyMore}
	\end{eqnarray}
	
	Since we are looking for the optimal amount In ( \(\Delta\beta_{0}\) ), we can make the following simplifications.
	
	\begin{eqnarray}
		let \: x &=& \Delta\beta_{0}\\
		let \: C_{A} &=& 997^2 R_{\beta 1}  R_{\alpha 0}\\
		let \: C_{B} &=& 1000^2 R_{\beta 0} R_{\alpha 1}\\
		let \: C_{C} &=& 997000  R_{\alpha 1}\\
		let \: C_{D} &=& 997^2  R_{\alpha 0}
	\end{eqnarray}
	
	Thus equation \ref{eqn:subyMore} can be reduced to equation \ref{eqn:reduceOut}.
	
	\begin{eqnarray}
		\Delta\beta_{1}  &=& \frac{C_{A} x}{C_{B} + x(C_{C} + C_{D})} \label{eqn:reduceOut}
	\end{eqnarray}
	
	Therefore the profit (y), from equation \ref{eqn:profit} can be expressed in terms of the amount In (x), shown in equation \ref{eqn:profit2}.
	
	\begin{eqnarray}
		y  &=& \frac{C_{A} x}{C_{B} + x(C_{C} + C_{D})} - x \label{eqn:profit2}\\
		&=& \frac{C_{A} x - x(C_{B} + x(C_{C} + C_{D}))}{C_{B} + x(C_{C} + C_{D})} \label{eqn:profit3}\\
		&=& \frac{x(C_{A} - C_{B}) - x^2(C_{C} + C_{D})}{C_{B} + x(C_{C} + C_{D})} \label{eqn:profit4}\\
		&=& \frac{x C_{F} - x^2 C_{G} }{C_{B} + x C_{G}} \label{eqn:profit5}
	\end{eqnarray}
	
	Where:
	\begin{eqnarray}
		C_{F}  &=& C_{A} - C_{B}\\
		C_{G}  &=& C_{C} + C_{D}
	\end{eqnarray}
	
	Maximum profit occurs at a turning point i.e. where the gradient or differential is zero, shown in equation \ref{eqn:turn}.
	
	\begin{eqnarray}
		\frac{dy}{dx} = 0 \label{eqn:turn}
	\end{eqnarray}
	
	Since we have a complex equation for differentiating, we can use the quotient rule from equation \ref{eqn:quotient}. Numerator and denominator differentials are shown in equations \ref{eqn:fdash} and \ref{eqn:gdash}.
	
	\begin{eqnarray}
		\frac{dy}{dx} &=& \frac{d \frac{ f(x)}{g(x)}}{dx} \label{eqn:turn2}\\
		f(x) &=& x C_{F} - x^2 C_{G} \label{eqn:f}\\
		g(x) &=& C_{B} + x C_{G} \label{eqn:g}\\
		\frac{f(x)}{dx} &=& C_{F} - 2 x C_{G} \label{eqn:fdash}\\
		\frac{g(x)}{dx} &=& C_{G} \label{eqn:gdash}
	\end{eqnarray}
	
	Combining the quotient rule with equation \ref{eqn:turn}, we get equation \ref{eqn:quoSolDex}, which expands to equation \ref{eqn:quoSol2}.
	
	\begin{eqnarray}
		f'g &=& g'f \label{eqn:quoSolDex}\\
		(C_{F} - 2 x C_{G})(C_{B} + x C_{G}) &=& C_{G} ( x C_{F} - x^2 C_{G}) \label{eqn:quoSol2}
	\end{eqnarray}
	
	Equation \ref{eqn:quoSol2} can be re-arranged to form a generic quadratic equation \ref{eqn:quadRefDex} and so the parameters can be defined for the quadratic solution in equation \ref{eqn:sol}.
	
	\begin{eqnarray}
		x^2 C_{G}^2 + x(2 C_{B} C_{G}) - C_{B} C_{F} &=& 0 \label{eqn:quadRefDex}
	\end{eqnarray}
	
	Solution to the optimal simple DEX arbitrage size for a given swap is shown in equation \ref{eqn:sol}.
	
	\begin{eqnarray}
		x^* &=& \frac{-(2 C_{B} C_{G}) \pm \sqrt{(2 C_{B} C_{G})^2 - 4(C_{G}^2)(- C_{B} C_{F})}}{2 C_{G}^2} \label{eqn:sol}
	\end{eqnarray}
	
	For positive roots only, this can be reduced to:
	
	\begin{eqnarray}
		x^* &=& \frac{- C_{B} + \sqrt{C_{B} ^2 + C_{B} C_{F}}}{C_{G}} \label{eqn:sol2}
	\end{eqnarray}
	

\chapter{Equivalence Checking}

\subsection{Backrun placement}

By definition, backruns must occur after user to user swap. From a design point of view the simplest place to insert the backrun function would be in the internal $_swap$ function which is called by the other swaps. However, some of the swap variants eg $swapTokensForExactETH$ perform user actions after $_swap$ is called. This is not ideal, as we do not want to interfere with the user swap. Moreover, other swap variants such as $swapExactTokensForTokensSupportingFeeOnTransferTokens$ do not use $_swap$. Backrun functions were therefore placed at the end of each external swap variant. E.g.

Original
\label{Before swapExactTokensforTokens:1}
\begin{minted}{lexer.py:SolidityLexer -x}
    function swapExactTokensForTokens(
       uint amountIn,
       uint amountOutMin,
       address[] calldata path,
       address to,
       uint deadline
    ) external virtual override ensure(deadline) returns (uint[] memory amounts) {
 amounts = UniswapV2Library.getAmountsOut(factory, amountIn, path);
 require(amounts[amounts.length - 1] 
 >= amountOutMin, 'UniswapV2Router: INSUFFICIENT_OUTPUT_AMOUNT');
    TransferHelper.safeTransferFrom(
            path[0], msg.sender, 
            UniswapV2Library.pairFor(factory, path[0], path[1]), amounts[0]
        );
        _swap(amounts, path, to);
    }
\end{minted}

Design change:

\label{After swapExactTokensforTokens:2}
\begin{minted}{lexer.py:SolidityLexer -x}
function swapExactTokensForTokens(
    uint amountIn,
    uint amountOutMin,
    address[] calldata path,
    address to,
    uint deadline
) external virtual override ensure(deadline) returns (uint[] memory amounts) {
    amounts = UniswapV2Library.getAmountsOut(factory, amountIn, path);
    require(amounts[amounts.length - 1] >= amountOutMin, 
    'UniswapV2Router: INSUFFICIENT_OUTPUT_AMOUNT');
    TransferHelper.safeTransferFrom(
        path[0],
        msg.sender, 
        UniswapV2Library.pairFor(factory, path[0], path[1]), amounts[0]
    );
    _swap(amounts, path, to);
    _backrunSwaps(path);
}
\end{minted}

Multiple factories
Multiple factories (at least 2) are required for the backrun arbitrage. The adoption of multiple factories within the router, lead to some internal function changes. In particular $pairFor$.

\label{CREATE2 Factory:3}
\begin{minted}{lexer.py:SolidityLexer -x}
// calculates the CREATE2 address for a pair without making any external calls
function pairFor(
address factory, 
address tokenA, 
address tokenB
) 
internal pure returns (address pair) {
(address token0, address token1) = sortTokens(tokenA, tokenB);
pair = address(uint160(uint(keccak256(abi.encodePacked(
    hex'ff',
    factory,
    keccak256(abi.encodePacked(token0, token1)),
    // hard coded factory init code hash
    hex'96e8ac4277198ff8b6f785478aa9a39f403cb768dd02cbee326c3e7da348845f'
    )))));
}
\end{minted}

Changes to 
\begin{minted}{lexer.py:SolidityLexer -x}

function pairFor(address factory, address tokenA, address tokenB) 
 internal view returns (address pair) {
    bytes memory factoryHash = factory
        == SUSHI_FACTORY ? SUSHI_FACTORY_HASH : BACKUP_FACTORY_HASH;

(address token0, address token1) = _sortTokens(tokenA, tokenB);
   pair = address(uint160(uint(keccak256(abi.encodePacked(
     hex'ff',
     factory,
     keccak256(abi.encodePacked(token0, token1)),
     factoryHash // init code hash
    )))));
}
\end{minted}

\subsection{Fallback factory}
Since the extra factory is required for the arbitrage, we can use it, for the user, to check for an available swap on the alternate factory if it would otherwise fail on the default factory through slippage.

\label{Fallback Factory:4}
\begin{minted}{lexer.py:SolidityLexer -x}
amounts = UniswapV2Library.getAmountsOut(factory, amountIn, path);
require(amounts[amounts.length - 1]
>= amountOutMin, 'UniswapV2Router: INSUFFICIENT_OUTPUT_AMOUNT');
\end{minted}
Changes to
\begin{minted}{lexer.py:SolidityLexer -x}
address factory = SUSHI_FACTORY;
amounts = _getAmountsOut(factory, amountIn, path);
if(amounts[amounts.length - 1] < amountOutMin){
    // Change 1 -> fallback for insufficient output amount, check backup router
    amounts = _getAmountsOut(BACKUP_FACTORY, amountIn, path);
    require(amounts[amounts.length - 1] 
    >= amountOutMin, 'UniswapV2Router: INSUFFICIENT_OUTPUT_AMOUNT');
    factory = BACKUP_FACTORY;
}
\end{minted}

\chapter{Math Libraries and BigInt support}

\paragraph{These following sections describe testing various math libraries to accommodate the additional calculations required of the router.}

\subsection{Uint256 overflow}
Optimal arbitrage calculations were overflowing uint256. e.g.
\label{Uint256 overflow:5}
\begin{minted}{lexer.py:SolidityLexer -x}
uint Cd = reserve0Token1.mul(997).mul(997);
uint Cc = reserve1Token1.mul(997000);
uint Cb = reserve1Token1.mul(reserve0Token0).mul(1000).mul(1000);
uint Ca = reserve1Token0.mul(reserve0Token1).mul(997).mul(997);
uint Cf = Ca - Cb;
uint Cg = Cc + Cd;
uint a = Cg * Cg;
uint b = 2 * Cb * Cg;
uint c = Cb * Cf;
uint d = (b*b) + ( 4 * a * c ); 
\end{minted}

would consistently overflow by $uint b$. Found out through individual checks:
\begin{minted}{lexer.py:SolidityLexer -x}
unchecked {
    uint a = Cg * Cg;
    require(a/Cg == Cg,"a overflow");
    uint b = 2 * Cb * Cg;
    require(b/Cb == 2*Cg ,"b overflow");
    uint c = Cb * Cf;
    require(c/Cb == Cf,"c overflow");
    uint d = (b*b) + ( 4 * a * c );
    require(d/(b*b) == 4*a*c,"d overflow");
}
\end{minted}
\newpage

ABDKMath \footnote{$https://github.com/abdk-consulting/abdk-libraries-solidity$} library was used for a time, as it avoided overflow by dropping to floats.

ABDKMath Example
\begin{minted}{lexer.py:SolidityLexer -x}
bytes16 _Cg = ABDKMathQuad.fromUInt(Cg);
bytes16 _a = ABDKMathQuad.mul(_Cg, _Cg);
\end{minted}

However we found this lost precision and failed echidna tests.
\label{Uint256 overflow:5}
\begin{lstlisting}

# echidna test
echidna_mulUint:  failed!
  Call sequence:
    setX1(1106235220955)
    setX(9390953368914254812617)


echidna_Uint_convertion:  failed!
  Call sequence:
    setX(10518526264810785485368401065708505)


echidna_divUint:  failed!
  Call sequence:
    setX(10417774989007224423389698535018119)
    setX1(1)
\end{lstlisting}


We also tried PRBMath\footnote{https://github.com/paulrberg/prb-math/} library. These faired better in echidna tests but still suffered overflow issues. 

\begin{lstlisting}
echidna_mulUint:  failed!
  Call sequence:
    setX(115916773041390072873637598212453390567932363729484377996870)


echidna_Uint_convertion:  failed!
  Call sequence:
    setX(115962837499224411198969207499961588040517688084412876519766)


echidna_divUint:  failed!
  Call sequence:
    setX(115989750869986627937072895547572258287879165164826483095329)
    setX1(1)
\end{lstlisting}


Ultimately we settled on Uint512 \footnote{see $github.com/SimonSuckut/Solidity_Uint512/blob/main/contracts/Uint512.sol$} which both passed echidna and overflow issue.
\begin{lstlisting}
echidna_mulUint:  passed! 
echidna_divUint:  passed!
\end{lstlisting}



\chapter{Conclusions and Future Work}

\newpage
%
% ---- Bibliography ----
%
% BibTeX users should specify bibliography style 'splncs04'.
% References will then be sorted and formatted in the correct style.
%
% \bibliographystyle{splncs04}
% \bibliography{mybibliography}
%
\chapter{Bibliography}
\begin{thebibliography}{1}
\bibitem{openmev}
OpenMEV source code, \url{github.com/manifoldfinance/OpenMevRouter}.
Last accessed 20 April 2022
	\bibliographystyle{unsrtnat}
	\bibliography{references}  %%% Uncomment this line and comment out the ``thebibliography'' section below to use the external .bib file (using bibtex) .
\newline 
\bibitem{Angeris2020}
Guillermo Angeris, Tarun Chitra, Alex Evans, Stephen Boyd
\newblock Guillermo Angeris et al. Optimal Routing for Constant Function Market Makers.	arXiv:2204.05238
\newblock In {\em arXiv 1911.03380}, 26 Jul 2021
    Optimization and Control (math.OC); Trading and Market Microstructure (q-fin.TR)

\hfill \break
\bibitem{Angeris2019}
Guillermo Angeris et al. An analysis of Uniswap markets. 2019. arXiv: 1911.03380
\newblock An analysis of Uniswap markets.
Mathematical Finance (q-fin.MF); Optimization and Control; Trading and Market Microstructure (q-fin.TR)
\newblock {\em arXiv: 1911.03380}, 

\hfill \break
\bibitem{Angeris2019}
Guillermo Angeris, Alex Evans, Tarun Chitra
\newblock Replicating Market Makers
Mathematical Finance (q-fin.MF); Optimization and Control; Trading and Market Microstructure (q-fin.TR)
\newblock {\em arXiv:2103.14769}, 26 Mar 2021.

\hfill \break
\bibitem{Tarun2021}
Guillermo Angeris, Alex Evans, Tarun Chitra
\newblock Constant Function Market Makers: Multi-Asset Trades via Convex Optimization
Mathematical Finance (q-fin.MF); Optimization and Control; Trading and Market Microstructure (q-fin.TR)
\newblock {\em arXiv:2107.12484 }, 26 Jul 2021]
\url{https://doi.org/10.48550/arXiv.2107.12484}

\hfill \break
\bibitem{Tarun2022}
Guillermo Angeris, Tarun Chitra, Alex Evans, Stephen Boyd
\newblock Optimal Routing for Constant Function Market Makers
Optimization and Control (math.OC); Trading and Market Microstructure (q-fin.TR)
\newblock {\em arXiv:2204.05238}, 11 Apr 2022]
\url{https://arxiv.org/abs/2204.05238v1}
\hfill \break

\hfill \break
\bibitem{Suckut, 2022}
Suckut, Simon 
\newblock Uint512 Solidity Library
\newblock {\em GitHub}, 11 Apr 2022]
\url{$https://github.com/SimonSuckut/Solidity_Uint512/blob/main/contracts/Uint512.sol$}



\end{thebibliography}
\end{document}
